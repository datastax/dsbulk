# Reference configuration for the DataStax Bulk Loader.
#
# All the values declared here will be used as defaults if you don't override them through
# command line arguments.
#
# This file is in HOCON format, see https://github.com/typesafehub/config/blob/master/HOCON.md.
#
# Note that a paragraph is written in one line, and paragraphs are separated by a blank line.
# This has the benefit of rendering well in markdown as well as plain-text help output (since
# the help text formatter wraps lines appropriately).

# Java Driver configuration.
#
# See the [Java Driver configuration reference](https://docs.datastax.com/en/developer/java-driver/4.3/manual/core/configuration/reference/)
# for instructions on how to configure the driver properly.
#
# The settings below provide an optimal driver configuration for DSBulk for most use cases.
datastax-java-driver {

  # Basic options.
  basic {

    # The contact points to use for the initial connection to the cluster.
    #
    # These are addresses of Cassandra nodes that the driver uses to discover the cluster topology. Only one contact point is required (the driver will retrieve the address of the other nodes automatically), but it is usually a good idea to provide more than one contact point, because if that single contact point is unavailable, the driver cannot initialize itself correctly.
    #
    # This must be a list of strings with each contact point specified as "host:port". If the host is a DNS name that resolves to multiple A-records, all the corresponding addresses will be used. Do not use "localhost" as the host name (since it resolves to both IPv4 and IPv6 addresses on some platforms).
    #
    # Note that Cassandra 3 and below requires all nodes in a cluster to share the same port (see CASSANDRA-7544).
    #
    # Note: on Cloud deployments, DSBulk automatically sets this option to an empty list, as contact points are not allowed to be explicitly provided when connecting to DataStax Apollo databases.
    # @type list<string>
    contact-points = ["127.0.0.1:9042"]

    # The location of the cloud secure bundle used to connect to Datastax Apache Cassandra as a
    # service.
    #
    # This setting must be a valid URL. If the protocol is not specified, it is implicitly assumed to be the `file://` protocol, in which case the value is expected to be a valid path on the local filesystem. For example, `/a/path/to/bundle` will be interpreted as `file:/a/path/to/bunde`. If the protocol is provided explicitly, then the value will be used as is.
    #
    # Note: if you set this to a non-null value, DSBulk assumes that you are connecting to an DataStax Apollo database; in this case, you should not set any of the following settings:
    #
    # - `datastax-java-driver.basic.contact-points`
    # - `datastax-java-driver.basic.request.consistency`
    # - `datastax-java-driver.advanced.ssl-engine-factory.*`
    #
    # If you do so, a log will be emitted and the setting will be ignored.
    # @type string
    cloud.secure-connect-bundle = null

    # How often the driver tries to reload the configuration. By default, hot-reloading is disabled in DSBulk.
    config-reload-interval = 0

    request {

      # How long the driver waits for a request to complete. This is a global limit on the duration of a session.execute() call, including any internal retries the driver might do.
      #
      # By default, this value is set pretty high to ensure that DDL queries don't time out, in order to provide the best experience for new users trying the driver with the out-of-the-box configuration. For any serious deployment, we recommend that you use separate configuration profiles for DDL and DML; you can then set the DML timeout much lower (down to a few milliseconds if needed).
      #
      # Note that, because timeouts are scheduled on the driver's timer thread, the duration specified here must be greater than the timer tick duration defined by the `advanced.netty.timer.tick-duration` setting (see below). If that is not the case, timeouts will not be triggered as timely as desired.
      timeout = 60 seconds

      # The consistency level to use for all queries. Note that stronger consistency levels usually result in reduced throughput. In addition, any level higher than `ONE` will automatically disable continuous paging, which can dramatically reduce read throughput.
      #
      # Valid values are: `ANY`, `LOCAL_ONE`, `ONE`, `TWO`, `THREE`, `LOCAL_QUORUM`, `QUORUM`, `EACH_QUORUM`, `ALL`.
      #
      # Note: on Cloud deployments, the only accepted consistency level when writing is `LOCAL_QUORUM`. Therefore, the default value is `LOCAL_ONE`, except when loading in Cloud deployments, in which case the default is automatically changed to `LOCAL_QUORUM`.
      consistency = LOCAL_ONE

      # The page size. This controls how many rows will be retrieved simultaneously in a single network roundtrip (the goal being to avoid loading too many results in memory at the same time). If there are more results, additional requests will be used to retrieve them (either automatically if you iterate with the sync API, or explicitly with the async API's `fetchNextPage` method). If the value is 0 or negative, it will be ignored and the request will not be paged.
      page-size = 5000

      # The serial consistency level. The allowed values are `SERIAL` and `LOCAL_SERIAL`.
      serial-consistency = LOCAL_SERIAL

      # The default idempotence for all queries executed in DSBulk. Setting this to false will cause all write failures to not be retried.
      default-idempotence = true

    }

    # The policy that decides the "query plan" for each query; that is, which nodes to try as coordinators, and in which order.
    load-balancing-policy {

      # The class of the policy. If it is not qualified, the driver assumes that it resides in the package `com.datastax.oss.driver.internal.core.loadbalancing`.
      #
      # DSBulk uses a special policy that infers the local datacenter from the contact points. You can also specify a custom class that implements `LoadBalancingPolicy` and has a public constructor with two arguments: the `DriverContext` and a `String` representing the profile name.
      class = com.datastax.dse.driver.internal.core.loadbalancing.DseDcInferringLoadBalancingPolicy

      # The datacenter that is considered "local": the default policy will only include nodes from this datacenter in its query plans. Set this to a non-null value if you want to force the local datacenter; otherwise, the `DseDcInferringLoadBalancingPolicy` used by default by DSBulk will infer the local datacenter from the provided contact points.
      # @type string
      local-datacenter = null

    }

  }

  # Advanced options.
  advanced {

    connection {

      # The timeout to use for internal queries that run as part of the initialization process, just after we open a connection. If this timeout fires, the initialization of the connection will fail. If this is the first connection ever, the driver will fail to initialize as well, otherwise it will retry the connection later.
      init-query-timeout = ${datastax-java-driver.basic.request.timeout}

      # The timeout to use when the driver changes the keyspace on a connection at runtime (this happens when the client issues a `USE ...` query, and all connections belonging to the current session need to be updated).
      set-keyspace-timeout = ${datastax-java-driver.basic.request.timeout}

      # The driver maintains a connection pool to each node, according to the distance assigned to it by the load balancing policy. If the distance is IGNORED, no connections are maintained.
      pool {

        # The number of connections in the pool for nodes considered as local.
        local.size = 8

        # The number of connections in the pool for nodes considered as remote. Note that the default load balancing policy used by DSBulk never considers remote nodes, so this setting has no effect when using the default load balancing policy.
        remote.size = 8

      }

      # The maximum number of requests that can be executed concurrently on a connection. This must be between 1 and 32768.
      max-requests-per-connection = 32768

    }

    # How long the driver waits for responses to control queries (e.g. fetching the list of nodes, refreshing the schema).
    control-connection.timeout = ${datastax-java-driver.basic.request.timeout}

    request {

      # Whether logging of server warnings generated during query execution should be disabled by the driver. All server generated warnings will be available programmatically via the ExecutionInfo object on the executed statement's ResultSet. If set to "false", this will prevent the driver from logging these warnings. The default for DSBulk is to disable driver-level query warnings, since these are already handled by DSBulk itself.
      #
      # NOTE: The log formatting for these warning messages will reuse the options defined for advanced.request-tracker.
      log-warnings = false

      # Whether a warning is logged when a request (such as a CQL `USE ...`) changes the active keyspace. The default for DSBulk is to disable warnings when issuing USE statements (DSBulk issues USE statements when necessary).
      warn-if-set-keyspace = false

    }

    # The component that handles authentication on each new connection.
    auth-provider {

      # The class of the provider. If it is not qualified, the driver assumes that it resides in one of the following packages:
      # - `com.datastax.oss.driver.internal.core.auth`
      # - `com.datastax.dse.driver.internal.core.auth`
      #
      # The DSE driver provides 3 implementations out of the box:
      # - `PlainTextAuthProvider`: uses plain-text credentials. It requires the `username` and `password` options. Should be used only when authenticating against Apache Cassandra(R) clusters; not recommended when authenticating against DSE clusters.
      # - `DsePlainTextAuthProvider`: provides SASL authentication using the PLAIN mechanism for DSE clusters secured with DseAuthenticator. It requires the `username` and `password` options, and optionally, an `authorization-id`.
      # - `DseGssApiAuthProvider`: provides GSSAPI authentication for DSE clusters secured with `DseAuthenticator`. Read the javadocs of this authenticator for detailed instructions.
      #
      # You can also specify a custom class that implements `AuthProvider` and has a public constructor with a `DriverContext` argument (to simplify this, the driver provides two abstract classes that can be extended: `DsePlainTextAuthProviderBase` and `DseGssApiAuthProviderBase`).
      #
      # You can also specify a custom class that implements AuthProvider and has a public constructor with a DriverContext argument.
      class = null

      # The username to use to authenticate against a cluster with authentication enabled. Providers that accept this setting:
      #
      #  - `PlainTextAuthProvider`
      #  - `DsePlainTextAuthProvider`
      #
      # @type string
      username = null

      # The password to use to authenticate against a cluster with authentication enabled. Providers that accept this setting:
      #
      #  - `PlainTextAuthProvider`
      #  - `DsePlainTextAuthProvider`
      #
      # @type string
      password = null

    }

    # The policy that controls if the driver retries requests that have failed on one node.
    retry-policy {

      # The class of the policy. If it is not qualified, the driver assumes that it resides in the package `com.datastax.oss.driver.internal.core.retry`. DSBulk uses by default a special retry policy that opinionately retries most errors up to `max-retries` times.
      #
      # You can also specify a custom class that implements `RetryPolicy` and has a public constructor with two arguments: the `DriverContext` and a `String` representing the profile name.
      class = com.datastax.dsbulk.engine.internal.policies.retry.MultipleRetryPolicy

      # How many times to retry a failed query. Only valid for use with DSBulk's default retry policy (`MultipleRetryPolicy`).
      max-retries = 10

    }

    # Metrics in DSBulk are all disabled by default.
    metrics {}

    # Options to control the execution of continuous paging requests. Only applicable for unloads, and only if this feature is available in the remote cluster, ignored otherwise. Also, you need to enable continuous paging at DSBulk level for this to work, see `dsbulk.executor.continuousPaging.enabled` (it is enabled by default).
    continuous-paging {

      # The page size. The value specified here can be interpreted in number of rows or in number of bytes, depending on the unit defined with page-unit (see below). It controls how many rows (or how much data) will be retrieved simultaneously in a single network roundtrip (the goal being to avoid loading too many results in memory at the same time). If there are more results, additional requests will be used to retrieve them (either automatically if you iterate with the sync API, or explicitly with the async API's fetchNextPage method). The default is the same as the driver's normal request page size, i.e., 5000 (rows).
      page-size = ${datastax-java-driver.basic.request.page-size}

      # Whether the page-size option should be interpreted in number of rows or bytes. The default is false, i.e., the page size will be interpreted in number of rows.
      page-size-in-bytes = false

      # The maximum number of pages to return. The default is zero, which means retrieve all pages.
      max-pages = 0

      # Returns the maximum number of pages per second. The default is zero, which means no limit.
      max-pages-per-second = 0

      # The maximum number of pages that can be stored in the local queue. This value must be positive. The default is 4.
      max-enqueued-pages = 4

      # Timeouts for continuous paging. Note that there is no global timeout for continuous paging as there is for regular queries, because continuous paging queries can take an arbitrarily long time to complete. Instead, timeouts are applied to each exchange between the driver and the coordinator. In other words, if the driver decides to retry, all timeouts are reset.
      timeout {

        # How long to wait for the coordinator to send the first page.
        first-page = ${datastax-java-driver.basic.request.timeout}

        # How long to wait for the coordinator to send subsequent pages.
        other-pages = ${datastax-java-driver.basic.request.timeout}

      }
    }
  }
}

# DSBulk configuration.
dsbulk {

  # Driver-specific configuration.
  #
  # **DEPRECATED**. This entire section is deprecated since DSBulk 1.4.0. Please configure the Java driver directly using the `datastax-java-driver` configuration namespace. Refer to the [DataStax Java Driver documentation](https://docs.datastax.com/en/developer/java-driver/4.3/) for more information.
  driver {

    # The contact points to use for the initial connection to the cluster. This must be a comma-separated list of hosts, each specified by a host-name or ip address. If the host is a DNS name that resolves to multiple A-records, all the corresponding addresses will be used. Do not use `localhost` as a host-name (since it resolves to both IPv4 and IPv6 addresses on some platforms). The port for all hosts must be specified with `driver.port`.
    #
    # This setting has no effect when connecting to an Apollo database with a secure connect bundle.
    #
    # **DEPRECATED**. Use `datastax-java-driver.basic.contact-points` instead.
    hosts = ["127.0.0.1"]

    # The native transport port to connect to. This must match DSE's [native_transport_port](https://docs.datastax.com/en/cassandra/2.1/cassandra/configuration/configCassandra_yaml_r.html#configCassandra_yaml_r__native_transport_port) configuration option.
    #
    # Note that all nodes in a cluster must accept connections on the same port number. Mixed-port clusters are not supported.
    #
    # This setting has no effect when connecting to an Apollo database with a secure connect bundle.
    #
    # **DEPRECATED**. Use `datastax-java-driver.basic.contact-points` instead.
    port = 9042

    # Native Protocol-specific settings.
    protocol {

      # Specify the compression algorithm to use. Valid values are: `NONE`, `LZ4`, `SNAPPY`.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.protocol.compression` instead.
      compression = NONE

    }

    # Pooling-specific settings.
    #
    # The driver maintains a connection pool to each node, according to the distance assigned to it by the load balancing policy. If the distance is `IGNORED`, no connections are maintained.
    pooling {

      # Pooling settings for nodes at LOCAL distance.
      local {

        # The number of connections in the pool for nodes at "local" distance.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.connection.pool.local.size` instead.
        connections = 8

        # The maximum number of requests (1 to 32768) that can be executed concurrently on a connection. If connecting to legacy clusters using protocol version 1 or 2, any value greater than 128 will be capped at 128 and a warning will be logged.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.connection.max-requests-per-connection` instead.
        requests = 32768

      }

      # Pooling settings for nodes at REMOTE distance.
      remote {

        # The number of connections in the pool for remote nodes.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.connection.pool.remote.size` instead.
        connections = 1

        # The maximum number of requests (1 to 32768) that can be executed concurrently on a connection. If connecting to legacy clusters using protocol version 1 or 2, any value greater than 128 will be capped at 128 and a warning will be logged.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.connection.max-requests-per-connection` instead.
        requests = 1024

      }

      # The heartbeat interval. If a connection stays idle for that duration (no reads), the driver sends a dummy message on it to make sure it's still alive. If not, the connection is trashed and replaced.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.heartbeat.interval` instead.
      heartbeat = 30 seconds

    }

    # Query-related settings.
    query {

      # The consistency level to use for all queries. Note that stronger consistency levels usually result in reduced throughput. In addition, any level higher than `ONE` will automatically disable continuous paging, which can dramatically reduce read throughput.
      #
      # Valid values are: `ANY`, `LOCAL_ONE`, `ONE`, `TWO`, `THREE`, `LOCAL_QUORUM`, `QUORUM`, `EACH_QUORUM`, `ALL`.
      #
      # Note: on Cloud deployments, the only accepted consistency level when writing is `LOCAL_QUORUM`. Therefore, the default value is `LOCAL_ONE`, except when loading in Cloud deployments, in which case the default is automatically changed to `LOCAL_QUORUM`.
      #
      # **DEPRECATED**. Use `datastax-java-driver.basic.request.consistency` instead.
      consistency = LOCAL_ONE

      # The serial consistency level to use for writes. Only applicable if the data is inserted using lightweight transactions, ignored otherwise. Valid values are: `SERIAL` and `LOCAL_SERIAL`.
      #
      # **DEPRECATED**. Use `datastax-java-driver.basic.request.serial-consistency` instead.
      serialConsistency = LOCAL_SERIAL

      # The page size, or how many rows will be retrieved simultaneously in a single network round trip. The ideal page size depends on the size of the rows being unloaded: larger page sizes may have a positive impact on throughput for small rows, and vice versa.
      # This setting will limit the number of results loaded into memory simultaneously during unloading or counting. Setting this value to any negative value or zero will disable paging, i.e., the entire result set will be retrieved in one pass (not recommended). Not applicable for loading. Note that this setting controls paging for regular queries; to customize the page size for continuous queries, use the `executor.continuousPaging.pageSize` setting instead.
      #
      # **DEPRECATED**. Use `datastax-java-driver.basic.request.page-size` instead.
      fetchSize = 5000

      # The default idempotence of statements generated by the loader.
      #
      # **DEPRECATED**. Use `datastax-java-driver.basic.request.default-idempotence` instead.
      idempotence = true

    }

    # Socket-related settings.
    socket {
      # The time the driver waits for a request to complete. This is a global limit on the duration of a `session.execute()` call, including any internal retries the driver might do.
      #
      # **DEPRECATED**. Use `datastax-java-driver.basic.request.timeout` instead.
      readTimeout = 60 seconds

    }

    # Authentication settings.
    #
    # **DEPRECATED**. see [the driver documentation page on authentication](https://docs.datastax.com/en/developer/java-driver/4.2/manual/core/authentication/) for more information.
    auth {

      # The name of the AuthProvider to use. Valid choices are:
      #
      #  - None: no authentication.
      #  - PlainTextAuthProvider: Uses `com.datastax.driver.core.PlainTextAuthProvider` for authentication. Supports SASL authentication using the `PLAIN` mechanism (plain text authentication).
      #  - DsePlainTextAuthProvider: Uses `com.datastax.driver.dse.auth.DsePlainTextAuthProvider` for authentication. Supports SASL authentication to DSE clusters using the `PLAIN` mechanism (plain text authentication), and also supports optional proxy authentication; should be preferred to `PlainTextAuthProvider` when connecting to secured DSE clusters.
      #  - DseGSSAPIAuthProvider: Uses `com.datastax.driver.dse.auth.DseGSSAPIAuthProvider` for authentication. Supports SASL authentication to DSE clusters using the `GSSAPI` mechanism (Kerberos authentication), and also supports optional proxy authentication.
      #    - Note: When using this provider you may have to set the `java.security.krb5.conf` system property to point to your `krb5.conf` file (e.g. set the `DSBULK_JAVA_OPTS` environment variable to `-Djava.security.krb5.conf=/home/user/krb5.conf`). See the [Oracle Java Kerberos documentation](https://docs.oracle.com/javase/7/docs/technotes/guides/security/jgss/tutorials/KerberosReq.html) for more details.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.class` instead.
      provider = None

      # The username to use. Providers that accept this setting:
      #
      #  - `PlainTextAuthProvider`
      #  - `DsePlainTextAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.username` instead.
      # @type string
      username = null

      # The password to use. Providers that accept this setting:
      #
      #  - `PlainTextAuthProvider`
      #  - `DsePlainTextAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.password` instead.
      # @type string
      password = null

      # An authorization ID allows the currently authenticated user to act as a different user (proxy authentication). Providers that accept this setting:
      #
      #  - `DsePlainTextAuthProvider`
      #  - `DseGSSAPIAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.authorization-id` instead.
      # @type string
      authorizationId = null

      # The Kerberos principal to use. For example, `user@datastax.com`. If left unspecified, the principal is chosen from the first key in the ticket cache or keytab. Providers that accept this setting:
      #
      #  - `DseGSSAPIAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.login-configuration.principal` instead.
      # @type string
      principal = null

      # The path of the Kerberos keytab file to use for authentication. If left unspecified, authentication uses a ticket cache. Providers that accept this setting:
      #
      #  - `DseGSSAPIAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.login-configuration.keyTab` instead.
      # @type string
      keyTab = null

      # The SASL service name to use. This value should match the username of the Kerberos service principal used by the DSE server. This information is specified in the `dse.yaml` file by the *service_principal* option under the *kerberos_options* section, and may vary from one DSE installation to another - especially if you installed DSE with an automated package installer. Providers that accept this setting:
      #
      #  - `DseGSSAPIAuthProvider`
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.auth-provider.service` instead.
      saslService = "dse"

    }

    # Encryption-specific settings.
    #
    # For more information about how to configure this section, see the Java Secure Socket Extension (JSSE) Reference Guide: http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html. You can also check the DataStax Java driver documentation on SSL: http://docs.datastax.com/en/developer/java-driver-dse/latest/manual/ssl/
    #
    # This setting has no effect when connecting to an Apollo database with a secure connect bundle.
    #
    # **DEPRECATED**. see [the driver documentation page on SSL](https://docs.datastax.com/en/developer/java-driver/4.2/manual/core/ssl/) for more information.
    ssl {

      # The SSL provider to use. Valid values are:
      #
      # - **None**: no SSL.
      # - **JDK**: uses the JDK SSLContext
      # - **OpenSSL**: uses Netty's native support for OpenSSL. It provides better performance and generates less garbage. This is the recommended provider when using SSL.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.ssl-engine-factory.class` instead. Also, note that SSL contexts created with any of these deprecated providers will always have hostname verification enabled. If you want to disable hostname verification, configure your SSL context directly through the driver and set the `datastax-java-driver.advanced.ssl-engine-factory.hostname-validation` option accordingly.
      provider = None

      # The cipher suites to enable. For example:
      #
      # `cipherSuites = ["TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"]`
      #
      # This property is optional. If it is not present, the driver won't explicitly enable cipher suites, which according to the JDK documentation results in "a minimum quality of service".
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.ssl-engine-factory.cipher-suites` instead.
      cipherSuites = []

      # The truststore to use to validate remote peer certificates. This section is valid for both JDK and OpenSSL providers.
      truststore {

        # The path of the truststore file. This setting is optional. If left unspecified, server certificates will not be validated.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.ssl-engine-factory.truststore-path` instead.
        # @type string
        path = null

        # The truststore password.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.ssl-engine-factory.truststore-password` instead.
        # @type string
        password = null

        # The algorithm to use for the SSL truststore. Valid values are: `PKIX`, `SunX509`.
        #
        # **DEPRECATED**. Use `datastax-java-driver.advanced.ssl-engine-factory.truststore-password` instead.
        algorithm = SunX509

      }

      # The keystore to use for client authentication.
      #
      # This section is only valid when using JDK provider; it is ignored otherwise.
      keystore {

        # The path of the keystore file. This setting is optional. If left unspecified, no client authentication will be used.
        # @type string
        path = null

        # The keystore password.
        # @type string
        password = null

        # The algorithm to use for the SSL keystore. Valid values are: `SunX509`, `NewSunX509`.
        #
        # **DEPRECATED**. Provide a custom implementation in `datastax-java-driver.advanced.ssl-engine-factory.class` if you need to change this; otherwise the driver now uses `TrustManagerFactory.getDefaultAlgorithm()` by default.
        algorithm = SunX509

      }

      # OpenSSL configuration for client authentication. This section is only valid when using OpenSSL provider; it is ignored otherwise.
      openssl {

        # The path of the certificate chain file. This setting is optional. If left unspecified, no client authentication will be used.
        #
        # **DEPRECATED**. Using OpenSSL is now considered a driver advanced feature; see [this documentation page](https://docs.datastax.com/en/developer/java-driver/4.2/manual/core/ssl/#netty) for more information.
        # @type string
        keyCertChain = null

        # The path of the private key file.
        #
        # **DEPRECATED**. Using OpenSSL is now considered a driver advanced feature; see [this documentation page](https://docs.datastax.com/en/developer/java-driver/4.2/manual/core/ssl/#netty) for more information.
        # @type string
        privateKey = null

      }

    }

    # The name of the timestamp generator to use. Only the following built-in options are supported:
    #
    # - AtomicMonotonicTimestampGenerator: timestamps are guaranteed to be unique across all client threads.
    # - ThreadLocalTimestampGenerator: timestamps are guaranteed to be unique within each thread only.
    # - ServerSideTimestampGenerator: do not generate timestamps, let the server assign them.
    #
    # **DEPRECATED**. Use `datastax-java-driver.advanced.timestamp-generator.class`.
    timestampGenerator = AtomicMonotonicTimestampGenerator

    # The name of the address translator to use. This is only needed if the nodes are not directly reachable from the machine on which dsbulk is running (for example, the dsbulk machine is in a different network region and needs to use a public IP, or it connects through a proxy).
    #
    # This setting has no effect when connecting to an Apollo database with a secure connect bundle.
    #
    # **DEPRECATED**. Use `datastax-java-driver.advanced.address-translator.class`. The only currently supported value is the default one, `IdentityTranslator`.
    addressTranslator = IdentityTranslator

    # Settings for various driver policies.
    policy {

      # Maximum number of retries for a timed-out request.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.retry-policy.max-retries`.
      maxRetries = 10

      # Load balancing policy settings.
      #
      # **DEPRECATED**. This section is now deprecated and obsolete; most of its settings have no effect anymore. DSBulk now uses `com.datastax.dse.driver.internal.core.loadbalancing.DseDcInferringLoadBalancingPolicy` by default. Refer to the [driver documentation page on load balancing](https://docs.datastax.com/en/developer/java-driver/4.2/manual/core/load_balancing/) for more details.
      lbp {

        # The name of the load balancing policy.
        #
        # **OBSOLETE**. This setting is not honored anymore. To specify a load balancing policy, use `datastax-java-driver.basic.load-balancing-policy.class`.
        # @type string
        name = null

        # Settings for the DseLoadBalancingPolicy. See the driver documentation for this policy for more details.
        # **OBSOLETE**. This section is not honored anymore.
        dse {

          # The child policy that the specified `dse` policy wraps.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          childPolicy = "roundRobin"

        }

        # Settings for the DCAwareRoundRobinPolicy. See the driver documentation for this policy for more details.
        # **OBSOLETE**. This section is not honored anymore, except for `dcAwareRoundRobin.localDc`.
        dcAwareRoundRobin {

          # The datacenter name (commonly dc1, dc2, etc.) local to the machine on which dsbulk is running, so that requests are sent to nodes in the local datacenter whenever possible.
          #
          # This setting has no effect when connecting to an Apollo database with a secure connect bundle.
          #
          # **DEPRECATED**. Use `datastax-java-driver.basic.load-balancing-policy.local-datacenter` instead.
          # @type string
          localDc = null

          # Enable or disable whether to allow remote datacenters to count for local consistency level in round robin awareness.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          allowRemoteDCsForLocalConsistencyLevel = false

          # The number of hosts per remote datacenter that the round robin policy should consider.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          usedHostsPerRemoteDc = 0

        }

        # Settings for the TokenAwarePolicy. See the driver documentation for this policy for more details.
        # **OBSOLETE**. This section is not honored anymore.
        tokenAware {

          # The child policy that the specified `tokenAware` policy wraps.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          childPolicy = "roundRobin"

          # Specify how to order replicas.
          #
          # Valid values are all `TokenAwarePolicy.ReplicaOrdering` enum constants:
          #
          # - RANDOM: Return replicas in a different, random order for each query plan. This is the default strategy;
          # for loading, it should be preferred has it can improve performance by distributing writes across replicas.
          # - TOPOLOGICAL: Order replicas by token ring topology, i.e. always return the "primary" replica first.
          # - NEUTRAL: Return the replicas in the exact same order in which they appear in the child policy's query plan.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          replicaOrdering = RANDOM

        }

        # Settings for the WhiteListPolicy. See the driver documentation for this policy for more details.
        # **OBSOLETE**. This section is not honored anymore, except for `whiteList.hosts`.
        whiteList {

          # The child policy that the specified `whiteList` policy wraps.
          #
          # **OBSOLETE**. This setting is not honored anymore.
          childPolicy = "roundRobin"

          # List of hosts to white list. This must be a comma-separated list of hosts, each specified by a host-name or ip address. If the host is a DNS name that resolves to multiple A-records, all the corresponding addresses will be used. Do not use `localhost` as a host-name (since it resolves to both IPv4 and IPv6 addresses on some platforms).
          #
          # **DEPRECATED**. Use `datastax-java-driver.basic.load-balancing-policy.filter.class` instead.
          hosts = []

        }

      }

    }

  }

  # Log and error management settings.
  log {

    # The desired level of verbosity. Valid values are:
    #
    # - 0 (quiet): DSBulk will only log WARN and ERROR messages.
    # - 1 (normal): DSBulk will log INFO, WARN and ERROR messages.
    # - 2 (verbose) DSBulk will log DEBUG, INFO, WARN and ERROR messages.
    verbosity = 1

    # The writable directory where all log files will be stored; if the directory specified does not exist, it will be created. URLs are not acceptable (not even `file:/` URLs). Log files for a specific run, or execution, will be located in a sub-directory under the specified directory. Each execution generates a sub-directory identified by an "execution ID". See `engine.executionId` for more information about execution IDs. Relative paths will be resolved against the current working directory. Also, for convenience, if the path begins with a tilde (`~`), that symbol will be expanded to the current user's home directory.
    directory = "./logs"

    # The maximum number of errors to tolerate before aborting the entire operation. This can be expressed either as an absolute number of errors – in which case, set this to an integer greater than or equal to zero; or as a percentage of total rows processed so far – in which case, set this to a string of the form `N%`, where `N` is a decimal number between 0 and 100 exclusive (e.g. "20%"). Setting this value to any negative integer disables this feature (not recommended).
    maxErrors = 100

    # The maximum number of query warnings to log before muting them. Query warnings are sent by the server (for example, if the number of statements in a batch is greater than the warning threshold configured on the server). They are useful to diagnose suboptimal configurations but tend to be too invasive, which is why DSBulk by default will only log the 50 first query warnings; any subsequent warnings will be muted and won't be logged at all. Setting this value to any negative integer disables this feature (not recommended).
    maxQueryWarnings = 50

    # Whether or not to use ANSI colors and other escape sequences in log messages printed to the console. Valid values are:
    #
    # - `normal`: this is the default option. DSBulk will only use ANSI when the terminal is:
    #   - compatible with ANSI escape sequences; all common terminals on *nix and BSD systems, including MacOS, are ANSI-compatible, and some popular terminals for Windows (Mintty, MinGW);
    #   - a standard Windows DOS command prompt (ANSI sequences are translated on the fly).
    # - `force`: DSBulk will use ANSI, even if the terminal has not been detected as ANSI-compatible.
    # - `disable`: DSBulk will not use ANSI.
    #
    # Note to Windows users: ANSI support on Windows works best when the Microsoft Visual C++ 2008 SP1 Redistributable Package is installed; you can download it [here](https://www.microsoft.com/en-us/download/details.aspx?displaylang=en&id=5582).
    ansiMode = normal

    # Settings controlling how statements are printed to log files.
    stmt {

      # The desired log level. Valid values are:
      #
      # - ABRIDGED: Print only basic information in summarized form.
      # - NORMAL: Print basic information in summarized form, and the statement's query string, if available. For batch statements, this verbosity level also prints information about the batch's inner statements.
      # - EXTENDED: Print full information, including the statement's query string, if available, and the statement's bound values, if available. For batch statements, this verbosity level also prints all information available about the batch's inner statements.
      level = EXTENDED

      # The maximum length for a query string. Query strings longer than this value will be truncated.
      #
      # Setting this value to `-1` disables this feature (not recommended).
      maxQueryStringLength = 500

      # The maximum number of bound values to print. If the statement has more bound values than this limit, the exceeding values will not be printed.
      #
      # Setting this value to `-1` makes the maximum number of bound values unlimited (not recommended).
      maxBoundValues = 50

      # The maximum length for a bound value. Bound values longer than this value will be truncated.
      #
      # Setting this value to `-1` makes the maximum length for a bound value unlimited (not recommended).
      maxBoundValueLength = 50

      # The maximum number of inner statements to print for a batch statement. Only applicable for batch statements, ignored otherwise. If the batch statement has more children than this value, the exceeding child statements will not be printed.
      #
      # Setting this value to `-1` disables this feature (not recommended).
      maxInnerStatements = 10

    }

    # Settings controlling how rows are printed to log files.
    row {

      # The maximum number of result set values to print. If the row has more result set values than this limit, the exceeding values will not be printed.
      #
      # Setting this value to `-1` makes the maximum number of result set values unlimited (not recommended).
      maxResultSetValues = 50

      # The maximum length for a result set value. Result set values longer than this value will be truncated.
      #
      # Setting this value to `-1` makes the maximum length for a result set value unlimited (not recommended).
      maxResultSetValueLength = 50

    }
  }

  # Conversion-specific settings. These settings apply for both load and unload workflows.
  #
  # When writing, these settings determine how record fields emitted by connectors are parsed.
  #
  # When unloading, these settings determine how row cells emitted by DSE are formatted.
  #
  # When counting, these settings are ignored.
  codec {

    # The locale to use for locale-sensitive conversions.
    locale = en_US

    # The time zone to use for temporal conversions. When loading, the time zone will be used to obtain a timestamp from inputs that do not convey any explicit time zone information. When unloading, the time zone will be used to format all timestamps.
    timeZone = UTC

    # Comma-separated list of case-sensitive strings that should be mapped to `null`. For loading, when a record field value exactly matches one of the specified strings, the value is replaced with `null` before writing to DSE. For unloading, this setting is only applicable for string-based connectors, such as the CSV connector: the first string specified will be used to change a row cell containing `null` to the specified string when written out.
    #
    # For example, setting this to `["NULL"]` will cause a field containing the word `NULL` to be mapped to `null` while loading, and a column containing `null` to be converted to the word `NULL` while unloading.
    #
    # The default value is `[]` (no strings are mapped to `null`). In the default mode, DSBulk behaves as follows:
    # * When loading, if the target CQL type is textual (i.e. text, varchar or ascii), the original field value is left untouched; for other types, if the value is an empty string, it is converted to `null`.
    # * When unloading, all `null` values are converted to an empty string.
    #
    # Note that, regardless of this setting, DSBulk will always convert empty strings to `null` if the target CQL type is not textual (i.e. not text, varchar or ascii).
    #
    # This setting is applied before `schema.nullToUnset`, hence any `null` produced by a null-string can still be left unset if required.
    nullStrings: []

    # Specify how true and false representations can be used by dsbulk. Each representation is of the form `true_value:false_value`, case-insensitive. For loading, all representations are honored: when a record field value exactly matches one of the specified strings, the value is replaced with `true` of `false` before writing to DSE. For unloading, this setting is only applicable for string-based connectors, such as the CSV connector: the first representation will be used to format booleans before they are written out, and all others are ignored.
    booleanStrings = ["1:0", "Y:N", "T:F", "YES:NO", "TRUE:FALSE"]

    # Set how true and false representations of numbers are interpreted. The representation is of the form `true_value,false_value`. The mapping is reciprocal, so that numbers are mapping to Boolean and vice versa. All numbers unspecified in this setting are rejected.
    booleanNumbers = [1, 0]

    # The `DecimalFormat` pattern to use for conversions between `String` and CQL numeric types.
    #
    # See [java.text.DecimalFormat](https://docs.oracle.com/javase/8/docs/api/java/text/DecimalFormat.html) for details about the pattern syntax to use.
    #
    # Most inputs are recognized: optional localized thousands separator, localized decimal separator, or optional exponent. Using locale `en_US`, `1234`, `1,234`, `1234.5678`, `1,234.5678` and `1,234.5678E2` are all valid. For unloading and formatting, rounding may occur and cause precision loss. See `codec.formatNumbers` and `codec.roundingStrategy`.
    number = "#,###.##"

    # Whether or not to use the `codec.number` pattern to format numeric output. When set to `true`, the numeric pattern defined by `codec.number` will be applied. This allows for nicely-formatted output, but may result in rounding (see `codec.roundingStrategy`), or alteration of the original decimal's scale. When set to `false`, numbers will be stringified using the `toString()` method, and will never result in rounding or scale alteration. Only applicable when unloading, and only if the connector in use requires stringification, because the connector, such as the CSV connector, does not handle raw numeric data; ignored otherwise.
    formatNumbers = false

    # The rounding strategy to use for conversions from CQL numeric types to `String`.
    #
    # Valid choices: any `java.math.RoundingMode` enum constant name, including: `CEILING`, `FLOOR`, `UP`, `DOWN`, `HALF_UP`, `HALF_EVEN`, `HALF_DOWN`, and `UNNECESSARY`. The precision used when rounding is inferred from the numeric pattern declared under `codec.number`. For example, the default `codec.number` (`#,###.##`) has a rounding precision of 2, and the number 123.456 would be rounded to 123.46 if `roundingStrategy` was set to `UP`. The default value will result in infinite precision, and ignore the `codec.number` setting.
    #
    # Only applicable when unloading, if `codec.formatNumbers` is true and if the connector in use requires stringification, because the connector, such as the CSV connector, does not handle raw numeric data; ignored otherwise.
    roundingStrategy = UNNECESSARY

    # This setting can mean one of three possibilities:
    #
    # - The value is outside the range of the target CQL type. For example, trying to convert 128 to a CQL `tinyint` (max value of 127) results in overflow.
    # - The value is decimal, but the target CQL type is integral. For example, trying to convert 123.45 to a CQL `int` results in overflow.
    # - The value's precision is too large for the target CQL type. For example, trying to insert 0.1234567890123456789 into a CQL `double` results in overflow, because there are too many significant digits to fit in a 64-bit double.
    #
    # Valid choices:
    #
    # - `REJECT`: overflows are considered errors and the data is rejected. This is the default value.
    # - `TRUNCATE`: the data is truncated to fit in the target CQL type. The truncation algorithm is similar to the narrowing primitive conversion defined in The Java Language Specification, Section 5.1.3, with the following exceptions:
    #     - If the value is too big or too small, it is rounded up or down to the maximum or minimum value allowed, rather than truncated at bit level. For example, 128 would be rounded down to 127 to fit in a byte, whereas Java would have truncated the exceeding bits and converted to -127 instead.
    #     - If the value is decimal, but the target CQL type is integral, it is first rounded to an integral using the defined rounding strategy, then narrowed to fit into the target type. This can result in precision loss and should be used with caution.
    #
    # Only applicable for loading, when parsing numeric inputs; it does not apply for unloading, since formatting never results in overflow.
    overflowStrategy = REJECT

    # The temporal pattern to use for `String` to CQL `timestamp` conversion. Valid choices:
    #
    # - A date-time pattern such as `yyyy-MM-dd HH:mm:ss`.
    # - A pre-defined formatter such as `ISO_ZONED_DATE_TIME` or `ISO_INSTANT`. Any public static field in `java.time.format.DateTimeFormatter` can be used.
    # - The special formatter `CQL_TIMESTAMP`, which is a special parser that accepts all valid CQL literal formats for the `timestamp` type.
    # - The special formatter `UNITS_SINCE_EPOCH`, which is a special parser that reads and writes timestamps as numbers representing time units since a given epoch; the unit and the epoch to use can be specified with `codec.unit` and `codec.timestamp`.
    #
    # For more information on patterns and pre-defined formatters, see [Patterns for Formatting and Parsing](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) in Oracle Java documentation.
    #
    # For more information about CQL date, time and timestamp literals, see [Date, time, and timestamp format](https://docs.datastax.com/en/dse/6.0/cql/cql/cql_reference/refDateTimeFormats.html?hl=timestamp).
    #
    # The default value is the special `CQL_TIMESTAMP` value. When parsing, this format recognizes all CQL temporal literals; if the input is a local date or date/time, the timestamp is resolved using the time zone specified under `timeZone`. When formatting, this format uses the `ISO_OFFSET_DATE_TIME` pattern, which is compliant with both CQL and ISO-8601.
    timestamp = "CQL_TIMESTAMP"

    # The temporal pattern to use for `String` to CQL `date` conversion. Valid choices:
    #
    # - A date-time pattern such as `yyyy-MM-dd`.
    # - A pre-defined formatter such as `ISO_LOCAL_DATE`. Any public static field in `java.time.format.DateTimeFormatter` can be used.
    # - The special formatter `UNITS_SINCE_EPOCH`, which is a special parser that reads and writes local dates as numbers representing time units since a given epoch; the unit and the epoch to use can be specified with `codec.unit` and `codec.timestamp`.
    #
    # For more information on patterns and pre-defined formatters, see [Patterns for Formatting and Parsing](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) in Oracle Java documentation.
    #
    # For more information about CQL date, time and timestamp literals, see [Date, time, and timestamp format](https://docs.datastax.com/en/dse/6.0/cql/cql/cql_reference/refDateTimeFormats.html?hl=timestamp).
    date = "ISO_LOCAL_DATE"

    # The temporal pattern to use for `String` to CQL `time` conversion. Valid choices:
    #
    # - A date-time pattern, such as `HH:mm:ss`.
    # - A pre-defined formatter, such as `ISO_LOCAL_TIME`. Any public static field in `java.time.format.DateTimeFormatter` can be used.
    # - The special formatter `UNITS_SINCE_EPOCH`, which is a special parser that reads and writes local times as numbers representing time units since a given epoch; the unit and the epoch to use can be specified with `codec.unit` and `codec.timestamp`.
    #
    # For more information on patterns and pre-defined formatters, see [Patterns for formatting and Parsing](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns) in Oracle Java documentation.
    #
    # For more information about CQL date, time and timestamp literals, see [Date, time, and timestamp format](https://docs.datastax.com/en/dse/6.0/cql/cql/cql_reference/refDateTimeFormats.html?hl=timestamp).
    time = "ISO_LOCAL_TIME"

    # This setting is used in the following situations:
    #
    # - When the target column is of CQL `timestamp` type, or when loading data through a `USING TIMESTAMP` clause, or when unloading data from a `writetime()` function call, and if `codec.timestamp` is set to `UNITS_SINCE_EPOCH`, then the time unit specified here is used to convert numeric data to and from temporals. For example, if the input is 123 and the time unit specified here is SECONDS, then the input will be interpreted as 123 seconds since `codec.epoch`.
    # - When loading, and the target CQL type is numeric, but the input is alphanumeric and represents a temporal literal, the time unit specified here will be used to convert the parsed temporal into a numeric value. For example, if the input is `2018-12-10T19:32:45Z` and the time unit specified here is SECONDS, then the parsed temporal will be converted into seconds since `codec.epoch`.
    #
    # All `TimeUnit` enum constants are valid choices.
    unit = MILLISECONDS

    # This setting is used in the following situations:
    #
    # - When the target column is of CQL `timestamp` type, or when loading to a `USING TIMESTAMP` clause, or when unloading from a `writetime()` function call, and if `codec.timestamp` is set to `UNITS_SINCE_EPOCH`, then the epoch specified here determines the relative point in time to use to convert numeric data to and from temporals. For example, if the input is 123 and the epoch specified here is `2000-01-01T00:00:00Z`, then the input will be interpreted as N `codec.unit`s since January 1st 2000.
    # - When loading, and the target CQL type is numeric, but the input is alphanumeric and represents a temporal literal, the time unit specified here will be used to convert the parsed temporal into a numeric value. For example, if the input is `2018-12-10T19:32:45Z` and the epoch specified here is `2000-01-01T00:00:00Z`, then the parsed timestamp will be converted to N `codec.unit`s since January 1st 2000.
    # - When parsing temporal literals, if the input does not contain a date part, then the date part of the instant specified here will be used instead. For example, if the input is `19:32:45` and the epoch specified here is `2000-01-01T00:00:00Z`, then the input will be interpreted `2000-01-01T19:32:45Z`.
    #
    # The value must be expressed in [`ISO_ZONED_DATE_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME) format.
    epoch = "1970-01-01T00:00:00Z"

    # Strategy to use when generating time-based (version 1) UUIDs from timestamps. Clock sequence and node ID parts of generated UUIDs are determined on a best-effort basis and are not fully compliant with RFC 4122. Valid values are:
    #
    # - RANDOM: Generates UUIDs using a random number in lieu of the local clock sequence and node ID. This strategy will ensure that the generated UUIDs are unique, even if the original timestamps are not guaranteed to be unique.
    # - FIXED: Preferred strategy if original timestamps are guaranteed unique, since it is faster. Generates UUIDs using a fixed local clock sequence and node ID.
    # - MIN: Generates the smallest possible type 1 UUID for a given timestamp. Warning: this strategy doesn't guarantee uniquely generated UUIDs and should be used with caution.
    # - MAX: Generates the biggest possible type 1 UUID for a given timestamp. Warning: this strategy doesn't guarantee uniquely generated UUIDs and should be used with caution.
    uuidStrategy = RANDOM
  }

  # Monitoring-specific settings.
  monitoring {

    # The report interval. DSBulk will print useful metrics about the ongoing operation at this rate. Durations lesser than one second will be rounded up to 1 second.
    reportRate = 5 seconds

    # The time unit used when printing throughput rates. Valid values: all `TimeUnit` enum constants.
    rateUnit = SECONDS

    # The time unit used when printing latency durations. Valid values: all `TimeUnit` enum constants.
    durationUnit = MILLISECONDS

    # The expected total number of writes. Optional, but if set, the console reporter will also print the overall achievement percentage. Setting this value to `-1` disables this feature.
    expectedWrites = -1

    # The expected total number of reads. Optional, but if set, the console reporter will also print the overall achievement percentage. Setting this value to `-1` disables this feature.
    expectedReads = -1

    # Whether or not to track the throughput in bytes. When enabled, DSBulk will track and display the number of bytes sent or received per second. While useful to evaluate how much data is actually being transferred, computing such metrics is CPU-intensive and may slow down the operation. This is why it is disabled by default. Also note that the heuristic used to compute data sizes is not 100% accurate and sometimes underestimates the actual size.
    trackBytes = false

    # Enable or disable JMX reporting. Note that to enable remote JMX reporting, several properties must also be set in the JVM during launch. This is accomplished via the `DSBULK_JAVA_OPTS` environment variable.
    jmx = true

    # Enable or disable CSV reporting. If enabled, CSV files containing metrics will be generated in the designated log directory.
    csv = false

  }

  # Schema-specific settings.
  schema {

    # Keyspace used for loading or unloading data. Keyspace names should not be quoted and are case-sensitive. `MyKeyspace` will match a keyspace named `MyKeyspace` but not `mykeyspace`. Required option if `schema.query` is not specified; otherwise, optional.
    # @type string
    keyspace: null

    # Table used for loading or unloading data. Table names should not be quoted and are case-sensitive. `MyTable` will match a table named `MyTable` but not `mytable`. Required option if `schema.query` is not specified; otherwise, optional.
    # @type string
    table: null

    # The query to use. If not specified, then *schema.keyspace* and *schema.table* must be specified, and dsbulk will infer the appropriate statement based on the table's metadata, using all available columns. If `schema.keyspace` is provided, the query need not include the keyspace to qualify the table reference.
    #
    # For loading, the statement can be any `INSERT`, `UPDATE` or `DELETE` statement. `INSERT` statements are preferred for most load operations, and bound variables should correspond to mapped fields; for example, `INSERT INTO table1 (c1, c2, c3) VALUES (:fieldA, :fieldB, :fieldC)`. `UPDATE` statements are required if the target table is a counter table, and the columns are updated with incremental operations (`SET col1 = col1 + :fieldA` where `fieldA` is a field in the input data). A `DELETE` statement will remove existing data during the load operation.
    #
    # For unloading and counting, the statement can be any regular `SELECT` statement. If the statement does not contain a WHERE clause, the engine will generate a token range restriction clause of the form: `WHERE token(...) > :start and token(...) <= :end` and will generate as many statements as there are token ranges in the cluster, thus allowing parallelization of reads while at the same time targeting coordinators that are also replicas. If the statement does contain a WHERE clause however, that clause will remain intact; the engine will only be able to parallelize the operation if that WHERE clause also includes a `token(...) > :start and token(...) <= :end` relation (the bound variables can have any name).
    #
    # Statements can use both named and positional bound variables. Named bound variables should be preferred, unless the protocol version in use does not allow them; they usually have names matching those of the columns in the destination table, but this is not a strict requirement; it is, however, required that their names match those of fields specified in the mapping. Positional variables can also be used, and will be named after their corresponding column in the destination table.
    #
    # Note: The query is parsed to discover which bound variables are present, and to map the variables correctly to fields.
    #
    # See *schema.mapping* setting for more information.
    # @type string
    query: null

    # Specify whether to map `null` input values to "unset" in the database, i.e., don't modify a potentially pre-existing value of this field for this row. Valid for load scenarios, otherwise ignore. Note that setting to false creates tombstones to represent `null`.
    #
    # Note that this setting is applied after the *codec.nullStrings* setting, and may intercept `null`s produced by that setting.
    #
    # This setting is ignored when counting. When set to true but the protocol version in use does not support unset values (i.e., all protocol versions lesser than 4), this setting will be forced to false and a warning will be logged.
    nullToUnset: true

    # The field-to-column mapping to use, that applies to both loading and unloading; ignored when counting. If not specified, the loader will apply a strict one-to-one mapping between the source fields and the database table. If that is not what you want, then you must supply an explicit mapping. Mappings should be specified as a map of the following form:
    #
    # - Indexed data sources: `0 = col1, 1 = col2, 2 = col3`, where `0`, `1`, `2`, are the zero-based indices of fields in the source data; and `col1`, `col2`, `col3` are bound variable names in the insert statement.
    #     - A shortcut to map the first `n` fields is to simply specify the destination columns: `col1, col2, col3`.
    # - Mapped data sources: `fieldA = col1, fieldB = col2, fieldC = col3`, where `fieldA`, `fieldB`, `fieldC`, are field names in the source data; and `col1`, `col2`, `col3` are bound variable names in the insert statement.
    #     - A shortcut to map fields named like columns is to simply specify the destination columns: `col1, col2, col3`.
    #
    # To specify that a field should be used as the timestamp (a.k.a. write-time) or ttl (a.k.a. time-to-live) of the inserted row, use the specially named fake columns `__ttl` and `__timestamp`: `fieldA = __timestamp, fieldB = __ttl`. Note that Timestamp fields are parsed as regular CQL timestamp columns and must comply with either `codec.timestamp`, or alternatively, with `codec.unit` + `codec.epoch`. TTL fields are parsed as integers representing durations in seconds, and must comply with `codec.number`.
    #
    # To specify that a column should be populated with the result of a function call, specify the function call as the input field (e.g. `now() = c4`). Note, this is only relevant for load operations. Similarly, to specify that a field should be populated with the result of a function call, specify the function call as the input column (e.g. `field1 = now()`). This is only relevant for unload operations. Function calls can also be qualified by a keyspace name: `field1 = ks1.max(c1,c2)`.
    #
    # In addition, for mapped data sources, it is also possible to specify that the mapping be partly auto-generated and partly explicitly specified. For example, if a source row has fields `c1`, `c2`, `c3`, and `c5`, and the table has columns `c1`, `c2`, `c3`, `c4`, one can map all like-named columns and specify that `c5` in the source maps to `c4` in the table as follows: `* = *, c5 = c4`.
    #
    # One can specify that all like-named fields be mapped, except for `c2`: `* = -c2`. To skip `c2` and `c3`: `* = [-c2, -c3]`.
    #
    # Any identifier, field or column, that is not strictly alphanumeric (i.e. not matching [a-zA-Z0-9_]+) must be surrounded by double-quotes, just like you would do in CQL: `"Field ""A""" = "Column 2"` (to escape a double-quote, simply double it). Note that, contrary to the CQL grammar, unquoted identifiers will not be lower-cased: an identifier such as `MyColumn1` will match a column named `"MyColumn1"` and not `mycolumn1`.
    #
    # The exact type of mapping to use depends on the connector being used. Some connectors can only produce indexed records; others can only produce mapped ones, while others are capable of producing both indexed and mapped records at the same time. Refer to the connector's documentation to know which kinds of mapping it supports.
    # @type string
    mapping: null

    # Specify whether or not to accept records that contain extra fields that are not declared in the mapping. For example, if a record contains three fields A, B, and C, but the mapping only declares fields A and B, then if this option is true, C will be silently ignored and the record will be considered valid, and if false, the record will be rejected. This setting also applies to user-defined types and tuples. Only applicable for loading, ignored otherwise.
    #
    # This setting is ignored when counting.
    allowExtraFields = true

    # Specify whether or not to accept records that are missing fields declared in the mapping. For example, if the mapping declares three fields A, B, and C, but a record contains only fields A and B, then if this option is true, C will be silently assigned null and the record will be considered valid, and if false, the record will be rejected. If the missing field is mapped to a primary key column, the record will always be rejected, since the database will reject the record. This setting also applies to user-defined types and tuples. Only applicable for loading, ignored otherwise.
    #
    # This setting is ignored when counting.
    allowMissingFields = false

    # The Time-To-Live (TTL) of inserted/updated cells during load (seconds); a value of -1 means there is no TTL. Not applicable to unloading nor counting. Ignored when `schema.query` is provided. For more information, see the [CQL Reference](https://docs.datastax.com/en/dse/6.0/cql/cql/cql_reference/cql_commands/cqlInsert.html#cqlInsert__ime-value), [Setting the time-to-live (TTL) for value](http://docs.datastax.com/en/dse/6.0/cql/cql/cql_using/useTTL.html), and [Expiring data with time-to-live](http://docs.datastax.com/en/dse/6.0/cql/cql/cql_using/useExpire.html).
    queryTtl = -1

    # The timestamp of inserted/updated cells during load; otherwise, the current time of the system running the tool is used. Not applicable to unloading nor counting. Ignored when `schema.query` is provided. The value must be expressed in [`ISO_ZONED_DATE_TIME`](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME) format.
    #
    # Query timestamps for DSE have microsecond resolution; any sub-microsecond information specified is lost. For more information, see the [CQL Reference](https://docs.datastax.com/en/dse/6.0/cql/cql/cql_reference/cql_commands/cqlInsert.html#cqlInsert__timestamp-value).
    # @type string
    queryTimestamp = null

    # The number of token range splits in which to divide the token ring. In other words, this setting determines how many read requests will be generated in order to read an entire table. Only used when unloading and counting; ignored otherwise. Note that the actual number of splits may be slightly greater or lesser than the number specified here, depending on the actual cluster topology and token ownership. Also, it is not possible to generate fewer splits than the total number of primary token ranges in the cluster, so the actual number of splits is always equal to or greater than that number. Set this to higher values if you experience timeouts when reading from DSE, specially if paging is disabled. The special syntax `NC` can be used to specify a number that is a multiple of the number of available cores, e.g. if the number of cores is 8, then 0.5C = 0.5 * 8 = 4 splits.
    splits = 8C

  }

  # Connector-specific settings. This section contains settings for the connector to use; it also contains sub-sections, one for each available connector.
  #
  # This setting is ignored when counting.
  connector {

    # The name of the connector to use.
    name = "csv"

  }

  # Batch-specific settings.
  #
  # These settings control how the workflow engine groups together statements before writing them.
  #
  # Only applicable for loading.
  batch {

    # The grouping mode. Valid values are:
    # - `DISABLED`: batching is disabled.
    # - `PARTITION_KEY`: groups together statements that share the same partition key. This is usually the most performant mode; however it may not work at all if the dataset is unordered, i.e., if partition keys appear randomly and cannot be grouped together.
    # - `REPLICA_SET`: groups together statements that share the same replica set. This mode works in all cases, but may incur in some throughput and latency degradation, specially with large clusters or high replication factors.
    # When tuning DSBulk for batching, the recommended approach is as follows:
    # 1. Start with `PARTITION_KEY`;
    # 2. If the average batch size is close to 1, try increasing `bufferSize`;
    # 3. If increasing `bufferSize` doesn't help, switch to `REPLICA_SET` and set `maxBatchStatements` or `maxSizeInBytes` to low values to avoid timeouts or errors;
    # 4. Increase `maxBatchStatements` or `maxSizeInBytes` to get the best throughput while keeping latencies acceptable.
    # The default is `PARTITION_KEY`.
    mode = PARTITION_KEY

    # **DEPRECATED**. Use `maxBatchStatements` instead.
    # @type number
    maxBatchSize = null

    # The maximum number of statements that a batch can contain. The ideal value depends on two factors:
    # - The data being loaded: the larger the data, the smaller the batches should be.
    # - The batch mode: when `PARTITION_KEY` is used, larger batches are acceptable, whereas when `REPLICA_SET` is used, smaller batches usually perform better. Also, when using `REPLICA_SET`, it is preferrable to keep this number below the threshold configured server-side for the setting `unlogged_batch_across_partitions_warn_threshold` (the default is 10); failing to do so is likely to trigger query warnings (see `log.maxQueryWarnings` for more information).
    # When set to a value lesser than or equal to zero, the maximum number of statements is considered unlimited. At least one of `maxBatchStatements` or `maxSizeInBytes` must be set to a positive value when batching is enabled.
    maxBatchStatements = 32

    # The maximum data size that a batch can hold. This is the number of bytes required to encode all the data to be persisted, without counting the overhead generated by the native protocol (headers, frames, etc.). The value specified here should be lesser than or equal to the value that has been configured server-side for the option `batch_size_fail_threshold_in_kb` in cassandra.yaml, but note that the heuristic used to compute data sizes is not 100% accurate and sometimes underestimates the actual size. See the documentation for the [https://docs.datastax.com/en/dse/6.0/dse-dev/datastax_enterprise/config/configCassandra_yaml.html#configCassandra_yaml__advProps](cassandra.yaml configuration file) for more information. When set to a value lesser than or equal to zero, the maximum data size is considered unlimited. At least one of `maxBatchStatements` or `maxSizeInBytes` must be set to a positive value when batching is enabled.
    maxSizeInBytes = -1

    # The buffer size to use for flushing batched statements. Should be set to a multiple of `maxBatchStatements`, e.g. 2 or 4 times that value; higher values consume more memory and usually do not incur in any noticeable performance gain. When set to a value lesser than or equal to zero, the buffer size is implicitly set to 4 times `maxBatchStatments`.
    bufferSize = -1

  }

  # Settings applicable for the count workflow, ignored otherwise.
  stats {

    # Which kind(s) of statistics to compute. Only applicaple for the count workflow, ignored otherwise. Possible values are:
    # * `global`: count the total number of rows in the table.
    # * `ranges`: count the total number of rows per token range in the table.
    # * `hosts`: count the total number of rows per hosts in the table.
    # * `partitions`: count the total number of rows in the N biggest partitions in the table. When using this mode, you can chose how many partitions to track with the `numPartitions` setting.
    # The default value is `[global]`.
    modes = [global]

    # The number of distinct partitions to count rows for. Only applicaple for the count workflow when `stats.mode` is `partitions`, ignored otherwise.
    numPartitions = 10

  }

  # Executor-specific settings.
  executor {

    # The maximum number of "in-flight" requests, or maximum number of concurrent requests waiting for a response from the server. This acts as a safeguard to prevent more requests than the cluster can handle. Batch statements count as one request. Reduce this value when the throughput for reads and writes cannot match the throughput of mappers; this is usually a sign that the workflow engine is not well calibrated and will eventually run out of memory. Setting this option to any negative value or zero will disable it.
    maxInFlight = 1024

    # The maximum number of concurrent operations per second. When loading, this means the maximum number of write requests per second; when unloading or counting, this means the maximum number of rows per second. This acts as a safeguard to prevent overloading the cluster. Batch statements are counted by the number of statements included. Reduce this setting when the latencies get too high and a remote cluster cannot keep up with throughput, as `dsbulk` requests will eventually time out. Setting this option to any negative value or zero will disable it.
    maxPerSecond = -1

    # Continuous-paging specific settings.
    #
    # Only applicable for unloads, and only if this feature is available in the remote cluster, ignored otherwise.
    #
    # This section is deprecated except for `continuousPaging.enabled` and `continuousPaging.maxConcurrentQueries`. Please configure other continuous paging options (such as page size, maximum pages, etc.) directly in the driver configuration section. See [DSE continuous paging tuning and support guide](https://www.datastax.com/blog/2017/04/dse-continuous-paging-tuning-and-support-guide) for more information.
    continuousPaging {

      # Enable or disable continuous paging. If the target cluster does not support continuous paging or if `driver.query.consistency` is not `ONE` or `LOCAL_ONE`, traditional paging will be used regardless of this setting.
      enabled = true

      # The unit to use for the `pageSize` setting. Possible values are: `ROWS`, `BYTES`.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.continuous-paging.page-size-in-bytes` instead.
      pageUnit = ROWS

      # The size of the page. The unit to use is determined by the `pageUnit` setting. The ideal page size depends on the size of the rows being unloaded: larger page sizes may have a positive impact on throughput for small rows, and vice versa.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.continuous-paging.page-size` instead.
      pageSize = 5000

      # The maximum number of pages to retrieve. Setting this value to zero retrieves all pages available.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.continuous-paging.max-pages` instead.
      maxPages = 0

      # The maximum number of pages per second. Setting this value to zero indicates no limit.
      #
      # **DEPRECATED**. Use `datastax-java-driver.advanced.continuous-paging.max-pages-per-second` instead.
      maxPagesPerSecond = 0

      # The maximum number of concurrent continuous paging queries that should be carried in parallel. Set this number to a value equal to or lesser than the value configured server-side for `continuous_paging.max_concurrent_sessions` in the cassandra.yaml configuration file (60 by default); otherwise some requests might be rejected. Settting this option to any negative value or zero will disable it.
      maxConcurrentQueries = 60
    }

  }

  # Workflow Engine-specific settings.
  engine {

    # Enable or disable dry-run mode, a test mode that runs the command but does not load data. Not applicable for unloading nor counting.
    dryRun = false

    # A unique identifier to attribute to each execution. When unspecified or empty, the engine will automatically generate identifiers of the following form: *workflow*_*timestamp*, where :
    #
    # - *workflow* stands for the workflow type (`LOAD`, `UNLOAD`, etc.);
    # - *timestamp* is the current timestamp formatted as `uuuuMMdd-HHmmss-SSSSSS` (see [https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns)) in UTC, with microsecond precision if available, and millisecond precision otherwise.
    #
    # When this identifier is user-supplied, it is important to guarantee its uniqueness; failing to do so may result in execution failures. It is also possible to provide templates here. Any format compliant with the formatting rules of [`String.format()`](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax) is accepted, and can contain the following parameters:
    #
    # - `%1$s` : the workflow type (`LOAD`, `UNLOAD`, etc.);
    # - `%2$t` : the current time (with microsecond precision if available, and millisecond precision otherwise);
    # - `%3$s` : the JVM process PID (this parameter might not be available on some operating systems; if its value cannot be determined, a random integer will be inserted instead).
    # @type string
    executionId = null

  }

  # This group of settings is purely internal to the connector and are the interface for
  # DSBulk's infrastructure to customize how some settings are exposed to the user.
  #
  # In particular, how settings are documented and shortcut options that map to
  # settings that are commonly specified in the command line.
  metaSettings {

    # Specify how settings should be prioritized in generated docs and help.
    # Common and preferred settings must be fully qualified, i.e., start with "dsbulk."
    docHints {
      commonSettings = [
        # DSBulk common settings
        dsbulk.schema.keyspace,
        dsbulk.schema.table,
        dsbulk.schema.mapping,
        dsbulk.engine.dryRun,
        dsbulk.executor.maxPerSecond,
        dsbulk.log.maxErrors,
        dsbulk.log.directory,
        dsbulk.log.verbosity,
        dsbulk.monitoring.reportRate,
        # Driver common settings
        datastax-java-driver.basic.contact-points,
        datastax-java-driver.advanced.auth-provider.username,
        datastax-java-driver.advanced.auth-provider.password
      ]
      preferredSettings = [
      ]
      driverSettings = [
        datastax-java-driver.basic.load-balancing-policy.local-datacenter,
        datastax-java-driver.basic.cloud.secure-connect-bundle,
        datastax-java-driver.basic.request.consistency,
        datastax-java-driver.advanced.retry-policy.max-retries,
      ]
    }

    # Specify shortcuts for "long" options.
    # Shortcuts must be fully qualified, i.e., start with "dsbulk." or "datastax-java-driver."
    shortcuts {

      # DSBulk general shortcuts
      c = dsbulk.connector.name
      locale = dsbulk.codec.locale
      timeZone = dsbulk.codec.timeZone
      nullStrings = dsbulk.codec.nullStrings
      dryRun = dsbulk.engine.dryRun
      maxErrors = dsbulk.log.maxErrors
      logDir = dsbulk.log.directory
      verbosity = dsbulk.log.verbosity
      jmx = dsbulk.monitoring.jmx
      reportRate = dsbulk.monitoring.reportRate
      k = dsbulk.schema.keyspace
      m = dsbulk.schema.mapping
      query = dsbulk.schema.query
      t = dsbulk.schema.table
      stats = dsbulk.stats.modes
      partitions = dsbulk.stats.numPartitions

      # Driver shortcuts
      cp = datastax-java-driver.basic.contact-points
      dc = datastax-java-driver.basic.load-balancing-policy.local-datacenter
      b = datastax-java-driver.basic.cloud.secure-connect-bundle
      cl = datastax-java-driver.basic.request.consistency
      maxRetries = datastax-java-driver.advanced.retry-policy.max-retries
      u = datastax-java-driver.advanced.auth-provider.username
      p = datastax-java-driver.advanced.auth-provider.password

      # Driver deprecated shortcuts
      h = dsbulk.driver.hosts
      port = dsbulk.driver.port

    }
  }
}
