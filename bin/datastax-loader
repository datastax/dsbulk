#!/bin/sh

# Copyright (C) 2017 DataStax Inc.
#
# This software can be used solely with DataStax Enterprise. Please consult the license at
# http://www.datastax.com/terms/datastax-dse-driver-license-terms

function usage() {
  local BIN_NAME=`basename "$0"`
  cat << END
Usage: $BIN_NAME <options>
Options:
 -c, --connector.name <name>       Name of connector; may be the fqcn or simple name
                                   of an implementation of the Connector interface,
                                   or a prefix of the simple name. Only the built-in
                                   CSVConnector is supported at this time, so "csv"
                                   is a good value for this.
 -s, --connector.csv.url <source url or path>
                                   Url or file path of data to load.
 -k, --schema.keyspace <keyspace>  Keyspace into which to load data.
 -t, --schema.table <table>        Table into which to load data.
 -m, --schema.mapping <mapping>    Mapping of fields in data to columns in the database.

All arguments except connector.csv.url are optional in that values fall back to defaults
in conf/reference.conf or are inferred from the input data. In addition, any setting
specified in conf/reference.conf may be overridden on the command-line with a long
option.

NOTE: The user is free to update defaults in reference.conf to meet particular requirements,
      thus reducing the command-line arguments specified in invocations.

Examples:
* Load CSV data from /opt/data/export.csv to the ks1.table1 table in a cluster with
  a localhost contact point. Field names in the data match column names in the
  table. Field names are obtained from a "header row" in the data:

  $BIN_NAME -c csv -s /opt/data/export.csv -k ks1 -t table1 --connector.csv.header=true

* Connector-specific options like connector.csv.header are also available with a
  shortcut that eliminates the connector-specific name from the setting name:

  $BIN_NAME -c csv -s /opt/data/export.csv -k ks1 -t table1 --connector.header=true

* Same as last example, but load data from a url:
  $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 --connector.header=true

* Same as last example, but there is no header row and we specify an explicit field mapping based
  on field indices in the input:
  $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 -m "{0=col1,1=col3}"

* Same as last example, but specify a few contact points; note how the value is quoted:
  $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 -m "{0=col1,1=col3}" --driver.contactPoints '["10.200.1.3","10.200.1.4"]'

* Same as last example, but with connector-name, keyspace, table, and mapping set in
  conf/reference.conf:
  $BIN_NAME -s https://svr/data/export.csv --driver.contactPoints '["10.200.1.3","10.200.1.4"]'
END
}

# Canonicalize arguments
# * Convert short options to long; error out if an unknown option is encountered.
# * Handle -h / --help
# * Error out if positional args are specified; we don't support positional args.
function canonicalizeArgs() {
  local STATE=GETOPT
  while [ $# -gt 0 ] ; do
    if [ $STATE = GETOPT ] ; then
      # This is an option-name, "--option=value", or a simple positional arg.
      case "$1" in
        -h | --help | -h=* | --help=* )
          usage
          exit 0
          ;;
        --* )
          # Could be --option=value or just --option
          if echo "$1" | grep "=" > /dev/null 2>&1 ; then
            # option with value
            OPT=$(echo "$1" | sed -e 's/=.*//')
            VAL=$(echo "$1" | sed -e 's/[^=]*=//')
            PARSERESULT="$PARSERESULT $OPT '$VAL'"
          else
            # Just option; value is the next arg.
            PARSERESULT="$PARSERESULT $1"
            STATE=GETVAL
          fi
          ;;
        -* )
          # Short option; doesn't support =, so just add its long-option to the result
          case "$1" in
           -c ) LONG="--connector.name" ;;
           -s ) LONG="--connector.url" ;;
           -k ) LONG="--schema.keyspace" ;;
           -t ) LONG="--schema.table" ;;
           -m ) LONG="--schema.mapping" ;;
           * )
             # Unrecognized option!
             usage
             echo "\nUnrecognized option: $1" >&2
             exit 1
             ;;
          esac
          PARSERESULT="$PARSERESULT $LONG"
          STATE=GETVAL
          ;;
        * )
          # Simple positional arg...that's illegal
          usage
          echo "\nThis tool does not support positional arguments. " >&2
          echo "'$1' is invalid or belongs to an option." >&2
          exit 1
          ;;
      esac
    else
      # Value
      PARSERESULT="$PARSERESULT '$1'"
      STATE=GETOPT
    fi
    shift
  done
}

#### Main logic of script ####

# Use JAVA_HOME if set, otherwise look for java in PATH
if [ -n "$JAVA_HOME" ]; then
  if [ -x "$JAVA_HOME"/bin/java ]; then
    JAVA="$JAVA_HOME"/bin/java
  fi
elif [ -x /usr/libexec/java_home ] ; then
  JAVA=$(/usr/libexec/java_home)/bin/java
else
  JAVA=java
fi

if [ -z "$JAVA" ] ; then
  echo "Unable to find java executable. Check JAVA_HOME and PATH environment variables." >&2
  exit 1
fi

INSTALL_DIR=`dirname "$0"`/..

# Set CLASSPATH to include all the jars in the lib dir + the conf directory
# (which contains reference.conf).
for i in $INSTALL_DIR/lib/*.jar $INSTALL_DIR/conf; do
  CLASSPATH="$CLASSPATH:$i"
done

export CLASSPATH

# Parse command-line args.

canonicalizeArgs "$@"
eval set -- "$PARSERESULT"

while [ $# -gt 0 ] ; do
  OPT=$(echo $1 | sed -e 's/--//')
  VAL=$2
  if echo $VAL | grep -E '[#:]' > /dev/null 2>&1 ; then
    # The value has a special character in it. Quote the value.
    VAL="\"$VAL\""
  fi
  if [ -n "$LOADER_CONFIG" ] ; then
    LOADER_CONFIG="$LOADER_CONFIG,"
  fi
  LOADER_CONFIG="$LOADER_CONFIG$OPT=$VAL"
  shift 2
done

# Run the tool.
$JAVA com.datastax.loader.engine.Main $LOADER_CONFIG
