#!/bin/sh

# Copyright (C) 2017 DataStax Inc.
#
# This software can be used solely with DataStax Enterprise. Please consult the license at
# http://www.datastax.com/terms/datastax-dse-driver-license-terms

function usage() {
  local BIN_NAME=`basename "$0"`
  cat << END
Usage: $BIN_NAME <options>
Options:
 -c, --connector.name <name>       Name of connector; may be the fqcn or simple name
                                   of an implementation of the Connector interface,
                                   or a prefix of the simple name. Only the built-in
                                   CSVConnector is supported at this time, so "csv"
                                   is a good value for this.
 -s, --connector.url <source url or path>
                                   Url or file path of data to load; the actual meaning
                                   of this option depends on the selected connector.
 -k, --schema.keyspace <keyspace>  Keyspace into which to load data.
 -t, --schema.table <table>        Table into which to load data.
 -m, --schema.mapping <mapping>    Mapping of fields in data to columns in the database.

All arguments except connector.name and connector.url are optional in that
values fall back to defaults or are inferred from the input data.


CONFIG FILES, SETTINGS SEARCH ORDER, AND OVERRIDES:

Available settings along with defaults are recorded in conf/reference.conf. This file
also contains detailed descriptions of settings and is a great source of information.
When the loader starts up, settings are first loaded from conf/reference.conf.

The conf directory also contains an application.conf where a user may specify permanent
overrides of settings. These may be in nested-structure form like this:

datastax-loader {
  connector {
    name="csv"
  }
}

or dotted form: datastax-loader.connector.name="csv"

Finally, a user may specify impromptu overrides via long options on the command line.
See examples for details.


EXAMPLES:
* Load CSV data from stdin to the ks1.table1 table in a cluster with
  a localhost contact point. Field names in the data match column names in the
  table. Field names are obtained from a "header row" in the data:
    generate_data | $BIN_NAME -c csv -s stdin:/ -k ks1 -t table1 --connector.csv.header=true

* Same as last example, but load from a local file:
    $BIN_NAME -c csv -s ~/export.csv -k ks1 -t table1 --connector.csv.header=true

* Same as last example, but load data from a url:
    $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 --connector.csv.header=true

* Same as last example, but there is no header row and we specify an explicit field mapping based
  on field indices in the input:
    $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 -m "{0=col1,1=col3}"

* Same as last example, but specify a few contact points; note how the value is quoted because
  this setting is an array of strings:
    $BIN_NAME -c csv -s https://svr/data/export.csv -k ks1 -t table1 -m "{0=col1,1=col3}" --driver.contactPoints '["10.200.1.3:9042","10.200.1.4:9042"]'

* Same as last example, but with connector-name, keyspace, table, and mapping set in
  conf/application.conf:
    $BIN_NAME -s https://svr/data/export.csv --driver.contactPoints '["10.200.1.3:9042","10.200.1.4:9042"]'
END
}

# Canonicalize arguments
# * Convert short options to long; error out if an unknown option is encountered.
# * Handle -h / --help
# * Error out if positional args are specified; we don't support positional args.
function canonicalizeArgs() {
  local STATE=GETOPT
  while [ $# -gt 0 ] ; do
    if [ $STATE = GETOPT ] ; then
      # This is an option-name, "--option=value", or a simple positional arg.
      case "$1" in
        -h | --help | -h=* | --help=* )
          usage
          exit 0
          ;;
        --* )
          # Could be --option=value or just --option
          if echo "$1" | grep "=" > /dev/null 2>&1 ; then
            # option with value
            OPT=$(echo "$1" | sed -e 's/=.*//')
            VAL=$(echo "$1" | sed -e 's/[^=]*=//')
            PARSERESULT="$PARSERESULT $OPT '$VAL'"
          else
            # Just option; value is the next arg.
            PARSERESULT="$PARSERESULT $1"
            STATE=GETVAL
          fi
          ;;
        -* )
          # Short option; doesn't support =, so just add its long-option to the result
          case "$1" in
           -c ) LONG="--connector.name" ;;
           -s ) LONG="--connector.url" ;;
           -k ) LONG="--schema.keyspace" ;;
           -t ) LONG="--schema.table" ;;
           -m ) LONG="--schema.mapping" ;;
           * )
             # Unrecognized option!
             usage
             echo "\nUnrecognized option: $1" >&2
             exit 1
             ;;
          esac
          PARSERESULT="$PARSERESULT $LONG"
          STATE=GETVAL
          ;;
        * )
          # Simple positional arg...that's illegal
          usage
          echo "\nThis tool does not support positional arguments. " >&2
          echo "'$1' is invalid or belongs to an option." >&2
          exit 1
          ;;
      esac
    else
      # Value
      PARSERESULT="$PARSERESULT '$1'"
      STATE=GETOPT
    fi
    shift
  done
}

#### Main logic of script ####

# Look for a usable Java 8 binary in JAVA_HOME, the result of /usr/libexec/java_home, or path.
for J in "$JAVA_HOME"/bin/java "$(/usr/libexec/java_home 2> /dev/null)/bin/java" java ; do
  if [ -x $J ]; then
    VER=$($J -version 2>&1 | head -1 | sed -e 's/[^"]*"//' -e 's/".*//' -e 's/\.[^\.]*$//')
    MAJOR=$(echo $VER | sed -e 's/\..*$//')
    MINOR=$(echo $VER | sed -e 's/^.*\.//')
    if [ $MAJOR -ge 1 -a $MINOR -ge 8 ] ; then
      # This Java is at least 1.8.
      JAVA=$J
      break
    fi
  fi
done

if [ -z "$JAVA" ] ; then
  echo "Unable to find java 8 (or later) executable. Check JAVA_HOME and PATH environment variables." >&2
  exit 1
fi

INSTALL_DIR=`dirname "$0"`/..

# Set CLASSPATH to include all the jars in the lib dir + the conf directory
# (which contains reference.conf).
for i in $INSTALL_DIR/lib/*.jar $INSTALL_DIR/conf; do
  CLASSPATH="$CLASSPATH:$i"
done

export CLASSPATH

# Parse command-line args.

canonicalizeArgs "$@"
eval set -- "$PARSERESULT"

while [ $# -gt 0 ] ; do
  OPT=$(echo $1 | sed -e 's/--//')
  VAL=$2
  if ! echo $VAL | grep -E '^[\[{]' > /dev/null 2>&1 ; then
    if echo $VAL | grep -E '[#:]' > /dev/null 2>&1 ; then
      # The value has a special character in it. Quote the value.
      VAL="\"$VAL\""
    fi
  fi
  if [ -n "$LOADER_CONFIG" ] ; then
    LOADER_CONFIG="$LOADER_CONFIG,"
  fi
  LOADER_CONFIG="$LOADER_CONFIG$OPT=$VAL"
  shift 2
done

# Run the tool.
$JAVA com.datastax.loader.engine.Main $LOADER_CONFIG
